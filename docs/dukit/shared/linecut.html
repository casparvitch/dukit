<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>dukit.shared.linecut API documentation</title>
<meta name="description" content="This module contains …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dukit.shared.linecut</code></h1>
</header>
<section id="section-intro">
<p>This module contains&hellip;</p>
<p>TODO docs, as good as magsim.py</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module contains...

TODO docs, as good as magsim.py
&#34;&#34;&#34;

# ============================================================================

__author__ = &#34;Sam Scholten&#34;
__pdoc__ = {
    &#34;qdmpy.shared.LinecutSelectionWidget&#34;: True,
    &#34;qdmpy.shared.BulkLinecutWidget&#34;: True,
}

# ============================================================================

import numpy as np
import numpy.typing as npt
from matplotlib.image import AxesImage
import matplotlib.pyplot as plt
from scipy import integrate

# ============================================================================

import dukit.shared.widget
import dukit.shared.json2dict
import dukit.shared.itool

# ============================================================================


class BulkLinecutWidget:
    &#34;&#34;&#34;
    How to use
    ----------
    import matplotlib.pyplot as plt
    import numpy as np
    from qdmpy.shared.linecut import BulkLinecutWidget

    path = &#34;&lt;WHATEVER&gt;&#34;
    times = [0.325, 1, 5, 10, 20, 21, 22, 25, 30, 40]
    paths = [f&#34;{path}/{t}.txt&#34; for t in times]
    images = [np.loadtxt(p) for p in paths]
    selector_image = images[4]

    fig, axs = plt.subplots(ncols=3, figsize=(12, 6))
    axs[0].imshow(selector_image)  # (data can be nans if you want an empty selector)
    selector = BulkLinecutWidget(*axs, images, times)
    plt.show()
    selector.disconnect(path=&#34;/home/samsc/share/result.json&#34;)
    &#34;&#34;&#34;

    def __init__(
        self,
        imax: plt.Axes,
        profax: plt.Axes,
        resax: plt.Axes,
        images: list[npt.NDArray] | tuple[npt.NDArray],
        xlabels: list[str] | tuple[str],
        style: dict | None = None,
        useblit: bool = False,
        dointegral: bool = True,
    ):
        # check that input ax has an imshow (else not so useful eh)
        if not any([[isinstance(t, AxesImage) for t in imax.get_children()]]):
            raise ValueError(&#34;input axis does not contain an AxesImage (imshow).&#34;)
        self.images = images
        self.xlabels = xlabels

        self.pts = []

        dflt_style = {
            &#34;lineprops&#34;: {
                &#34;color&#34;: &#34;k&#34;,
                &#34;linestyle&#34;: &#34;-&#34;,
                &#34;linewidth&#34;: 1.0,
                &#34;alpha&#34;: 0.5,
            },
            &#34;markerprops&#34;: {
                &#34;marker&#34;: &#34;o&#34;,
                &#34;markersize&#34;: 2.0,
                &#34;mec&#34;: &#34;k&#34;,
                &#34;mfc&#34;: &#34;k&#34;,
                &#34;alpha&#34;: 0.5,
            },
        }

        self.lp = dflt_style[&#34;lineprops&#34;]
        self.mp = dflt_style[&#34;markerprops&#34;]

        if style is not None:
            if &#34;lineprops&#34; in style and isinstance(style[&#34;lineprops&#34;], dict):
                for key, item in style[&#34;lineprops&#34;].items():
                    self.lp[key] = item
            if &#34;markerprops&#34; in style and isinstance(style[&#34;markerprops&#34;], dict):
                for key, item in style[&#34;markerprops&#34;].items():
                    self.mp[key] = item

        self.line_selector = dukit.shared.widget.LineSelector(
            imax,
            self.onselect,
            ondraw=self.ondraw,
            lineprops=self.lp,
            markerprops=self.mp,
            vertex_select_radius=7.5 * 2.0,
            useblit=useblit,
        )
        self.imax = imax
        self.profax = profax
        self.resax = resax
        self.integrals = [0 for i in xlabels]
        self.integral = 0
        self.do_integral = dointegral

        self.canvas = self.imax.figure.canvas

        dummy_x = np.zeros((5, len(xlabels)))
        dummy_y = np.zeros((5, len(xlabels)))
        self.profiles = self.profax.plot(
            dummy_x, dummy_y, marker=&#34;o&#34;, ls=&#34;-&#34;, label=xlabels
        )
        # handles, _ = self.profax.get_legend_handles_labels()
        # self.profax.legend(handles, self.xlabels, loc=&#34;upper left&#34;)
        self.profax.legend()

        (self.integrals_plot,) = self.resax.plot(xlabels, self.integrals, &#34;ko-&#34;)

    def ondraw(self, verts):
        if len(verts) == 1:
            # change all profiles
            for p, prof in enumerate(self.profiles):
                prof.set_xdata([0])
                prof.set_ydata(self.images[p][int(verts[0][1]), int(verts[0][0])])
        else:
            idxs, jdxs = zip(*verts)
            pxl_ar = [0]
            i_lst = []
            j_lst = []
            for n in range(len(idxs) - 1):
                i0, i1 = idxs[n], idxs[n + 1]
                j0, j1 = jdxs[n], jdxs[n + 1]
                num = int(np.sqrt((i1 - i0) ** 2 + (j1 - j0) ** 2) * 2)  # *2 to be safe
                if not num:
                    continue

                ivec = np.linspace(i0, i1, num).astype(int)
                jvec = np.linspace(j0, j1, num).astype(int)

                new_ij = [
                    (ivec[v], jvec[u])
                    for v, u in zip(range(len(ivec) - 1), range(len(jvec) - 1))
                    if ivec[v + 1] != ivec[v] or jvec[u + 1] != jvec[u]
                ]
                new_ij.append((ivec[-1], jvec[-1]))
                new_is, new_js = zip(*new_ij)
                if not i_lst:
                    i_lst, j_lst = list(new_is), list(new_js)
                    i_ar, j_ar = np.asarray(new_is), np.asarray(new_js)
                else:
                    i_lst.extend(list(new_is[1:]))
                    j_lst.extend(list(new_js[1:]))
                    i_ar, j_ar = np.asarray(new_is[1:]), np.asarray(new_js[1:])
                if not (i_ar.ndim and i_ar.size):
                    continue
                pxl_ar.extend(
                    (
                        pxl_ar[-1]
                        + np.sqrt((i_ar - i_ar[0]) ** 2 + (j_ar - j_ar[0]) ** 2)
                    ).tolist()
                )

            for p, prof in enumerate(self.profiles):
                z = self.images[p][j_lst, i_lst]
                if z.ndim and z.size:  # ensure no empty array
                    prof.set_xdata(
                        pxl_ar[1:]
                    )  # get rid of initial 0 on pxl_ar (bit hacky)
                    prof.set_ydata(list(z))
                    if self.do_integral:
                        self.integrals[p] = integrate.simpson(z, pxl_ar[1:])
                    else:
                        self.integrals[p] = np.nan
                else:
                    # dummy data for this guy...
                    prof.set_xdata((np.nan,))
                    prof.set_ydata((np.nan,))
            self.integrals_plot.set_ydata(self.integrals)
        self.profax.relim()
        self.profax.autoscale_view()
        self.resax.relim()
        self.resax.autoscale_view()
        self.canvas.draw()
        self.canvas.flush_events()

    def onselect(self, verts):
        # only called when line is finished
        self.pts = verts  # list of vertices `[(Ax1, Ay1), (Ax2, Ay2)]`
        self.canvas.draw_idle()

    def disconnect(self, path=None):
        if path is not None:
            output_dict = {
                &#34;xlabels&#34;: self.xlabels,
                &#34;integrals&#34;: self.integrals,
                &#34;profile_x&#34;: np.transpose(
                    [prof.get_xdata() for prof in self.profiles]
                ).tolist(),
                &#34;profile_y&#34;: np.transpose(
                    [prof.get_ydata() for prof in self.profiles]
                ).tolist(),
            }
        dukit.shared.json2dict.dict_to_json(output_dict, path)
        self.line_selector.disconnect_events()
        self.canvas.draw_idle()


class LinecutSelectionWidget:
    &#34;&#34;&#34;
    How to Use
    ----------
    fig, axs = plt.subplots(ncols=2)
    axs[0].imshow(data) # (data may be nans if you want empty selector)
    selector = LinecutSelectionWidget(axs[0], axs[1], ...)
    plt.show()
    selector.disconnect()

    &#34;&#34;&#34;

    def __init__(self, imax, lineax, data, style=None, useblit=False):
        # check that input ax has an imshow (else not so useful eh)
        if not any([[isinstance(t, AxesImage) for t in imax.get_children()]]):
            raise ValueError(&#34;input axis does not contain an AxesImage (imshow).&#34;)

        self.data = data
        self.imax = imax
        self.lineax = lineax
        self.integral = 0

        self.canvas = self.imax.figure.canvas

        dflt_style = {
            &#34;lineprops&#34;: {
                &#34;color&#34;: &#34;k&#34;,
                &#34;linestyle&#34;: &#34;-&#34;,
                &#34;linewidth&#34;: 1.0,
                &#34;alpha&#34;: 0.5,
            },
            &#34;markerprops&#34;: {
                &#34;marker&#34;: &#34;o&#34;,
                &#34;markersize&#34;: 2.0,
                &#34;mec&#34;: &#34;k&#34;,
                &#34;mfc&#34;: &#34;k&#34;,
                &#34;alpha&#34;: 0.5,
            },
        }

        self.lp = dflt_style[&#34;lineprops&#34;]
        self.mp = dflt_style[&#34;markerprops&#34;]
        if style is not None:
            if &#34;lineprops&#34; in style and isinstance(style[&#34;lineprops&#34;], dict):
                for key, item in style[&#34;lineprops&#34;].items():
                    self.lp[key] = item
            if &#34;markerprops&#34; in style and isinstance(style[&#34;markerprops&#34;], dict):
                for key, item in style[&#34;markerprops&#34;].items():
                    self.mp[key] = item

        vsr = 7.5 * self.mp[&#34;markersize&#34;]  # linear scaling on what our select radius is

        (self.profile,) = self.lineax.plot([1, 2, 3], [1, 2, 3], &#34;ko-&#34;)
        self.lineax.title.set_text(f&#34;Integral: {self.integral}&#34;)

        self.pts = []
        self.line_selector = dukit.shared.widget.LineSelector(
            imax,
            self.onselect,
            ondraw=self.ondraw,
            lineprops=self.lp,
            markerprops=self.mp,
            vertex_select_radius=vsr,
            useblit=useblit,
        )

    def ondraw(self, verts):
        if len(verts) == 1:
            self.profile.set_xdata([0])
            self.profile.set_ydata(self.data[int(verts[0][1]), int(verts[0][0])])
            self.lineax.title.set_text(f&#34;Integral: {self.integral}&#34;)
        else:
            idxs, jdxs = zip(*verts)
            t_ar = [0]
            i_lst = []
            j_lst = []
            for n in range(len(idxs) - 1):
                i0, i1 = idxs[n], idxs[n + 1]
                j0, j1 = jdxs[n], jdxs[n + 1]
                num = int(np.sqrt((i1 - i0) ** 2 + (j1 - j0) ** 2) * 2)  # *2 to be safe
                if not num:
                    continue

                ivec = np.linspace(i0, i1, num).astype(int)
                jvec = np.linspace(j0, j1, num).astype(int)

                new_ij = [
                    (ivec[v], jvec[u])
                    for v, u in zip(range(len(ivec) - 1), range(len(jvec) - 1))
                    if ivec[v + 1] != ivec[v] or jvec[u + 1] != jvec[u]
                ]
                new_ij.append((ivec[-1], jvec[-1]))
                new_is, new_js = zip(*new_ij)
                if not i_lst:
                    i_lst, j_lst = list(new_is), list(new_js)
                    i_ar, j_ar = np.asarray(new_is), np.asarray(new_js)
                else:
                    i_lst.extend(list(new_is[1:]))
                    j_lst.extend(list(new_js[1:]))
                    i_ar, j_ar = np.asarray(new_is[1:]), np.asarray(new_js[1:])
                if not (i_ar.ndim and i_ar.size):
                    continue
                t_ar.extend(
                    (
                        t_ar[-1]
                        + np.sqrt((i_ar - i_ar[0]) ** 2 + (j_ar - j_ar[0]) ** 2)
                    ).tolist()
                )

            z = self.data[j_lst, i_lst]
            if z.ndim and z.size:  # ensure no empty array
                self.profile.set_xdata(
                    t_ar[1:]
                )  # get rid of initial 0 on t_ar (bit hacky)
                self.profile.set_ydata(list(z))
                self.integral = integrate.simpson(z, t_ar[1:])
                self.lineax.title.set_text(f&#34;Integral: {self.integral:.6e}&#34;)
        self.lineax.relim()
        self.lineax.autoscale_view()
        self.canvas.draw()
        self.canvas.flush_events()

    def onselect(self, verts):
        # only called when line is finished
        self.pts = verts  # list of vertices `[(Ax1, Ay1), (Ax2, Ay2)]`
        self.canvas.draw_idle()

    def disconnect(self):
        self.line_selector.disconnect_events()
        self.canvas.draw_idle()
        print()
        print(&#34;profile xdata:&#34;)
        print(self.profile.get_xdata())
        print(&#34;profile ydata:&#34;)
        print(self.profile.get_ydata())
        print(&#34;integral:&#34;)
        print(self.integral)
        print()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dukit.shared.linecut.BulkLinecutWidget"><code class="flex name class">
<span>class <span class="ident">BulkLinecutWidget</span></span>
<span>(</span><span>imax: matplotlib.axes._axes.Axes, profax: matplotlib.axes._axes.Axes, resax: matplotlib.axes._axes.Axes, images: list[numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]] | tuple[numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]], xlabels: list[str] | tuple[str], style: dict | None = None, useblit: bool = False, dointegral: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="how-to-use">How To Use</h2>
<p>import matplotlib.pyplot as plt
import numpy as np
from qdmpy.shared.linecut import BulkLinecutWidget</p>
<p>path = "<WHATEVER>"
times = [0.325, 1, 5, 10, 20, 21, 22, 25, 30, 40]
paths = [f"{path}/{t}.txt" for t in times]
images = [np.loadtxt(p) for p in paths]
selector_image = images[4]</p>
<p>fig, axs = plt.subplots(ncols=3, figsize=(12, 6))
axs[0].imshow(selector_image)
# (data can be nans if you want an empty selector)
selector = BulkLinecutWidget(*axs, images, times)
plt.show()
selector.disconnect(path="/home/samsc/share/result.json")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BulkLinecutWidget:
    &#34;&#34;&#34;
    How to use
    ----------
    import matplotlib.pyplot as plt
    import numpy as np
    from qdmpy.shared.linecut import BulkLinecutWidget

    path = &#34;&lt;WHATEVER&gt;&#34;
    times = [0.325, 1, 5, 10, 20, 21, 22, 25, 30, 40]
    paths = [f&#34;{path}/{t}.txt&#34; for t in times]
    images = [np.loadtxt(p) for p in paths]
    selector_image = images[4]

    fig, axs = plt.subplots(ncols=3, figsize=(12, 6))
    axs[0].imshow(selector_image)  # (data can be nans if you want an empty selector)
    selector = BulkLinecutWidget(*axs, images, times)
    plt.show()
    selector.disconnect(path=&#34;/home/samsc/share/result.json&#34;)
    &#34;&#34;&#34;

    def __init__(
        self,
        imax: plt.Axes,
        profax: plt.Axes,
        resax: plt.Axes,
        images: list[npt.NDArray] | tuple[npt.NDArray],
        xlabels: list[str] | tuple[str],
        style: dict | None = None,
        useblit: bool = False,
        dointegral: bool = True,
    ):
        # check that input ax has an imshow (else not so useful eh)
        if not any([[isinstance(t, AxesImage) for t in imax.get_children()]]):
            raise ValueError(&#34;input axis does not contain an AxesImage (imshow).&#34;)
        self.images = images
        self.xlabels = xlabels

        self.pts = []

        dflt_style = {
            &#34;lineprops&#34;: {
                &#34;color&#34;: &#34;k&#34;,
                &#34;linestyle&#34;: &#34;-&#34;,
                &#34;linewidth&#34;: 1.0,
                &#34;alpha&#34;: 0.5,
            },
            &#34;markerprops&#34;: {
                &#34;marker&#34;: &#34;o&#34;,
                &#34;markersize&#34;: 2.0,
                &#34;mec&#34;: &#34;k&#34;,
                &#34;mfc&#34;: &#34;k&#34;,
                &#34;alpha&#34;: 0.5,
            },
        }

        self.lp = dflt_style[&#34;lineprops&#34;]
        self.mp = dflt_style[&#34;markerprops&#34;]

        if style is not None:
            if &#34;lineprops&#34; in style and isinstance(style[&#34;lineprops&#34;], dict):
                for key, item in style[&#34;lineprops&#34;].items():
                    self.lp[key] = item
            if &#34;markerprops&#34; in style and isinstance(style[&#34;markerprops&#34;], dict):
                for key, item in style[&#34;markerprops&#34;].items():
                    self.mp[key] = item

        self.line_selector = dukit.shared.widget.LineSelector(
            imax,
            self.onselect,
            ondraw=self.ondraw,
            lineprops=self.lp,
            markerprops=self.mp,
            vertex_select_radius=7.5 * 2.0,
            useblit=useblit,
        )
        self.imax = imax
        self.profax = profax
        self.resax = resax
        self.integrals = [0 for i in xlabels]
        self.integral = 0
        self.do_integral = dointegral

        self.canvas = self.imax.figure.canvas

        dummy_x = np.zeros((5, len(xlabels)))
        dummy_y = np.zeros((5, len(xlabels)))
        self.profiles = self.profax.plot(
            dummy_x, dummy_y, marker=&#34;o&#34;, ls=&#34;-&#34;, label=xlabels
        )
        # handles, _ = self.profax.get_legend_handles_labels()
        # self.profax.legend(handles, self.xlabels, loc=&#34;upper left&#34;)
        self.profax.legend()

        (self.integrals_plot,) = self.resax.plot(xlabels, self.integrals, &#34;ko-&#34;)

    def ondraw(self, verts):
        if len(verts) == 1:
            # change all profiles
            for p, prof in enumerate(self.profiles):
                prof.set_xdata([0])
                prof.set_ydata(self.images[p][int(verts[0][1]), int(verts[0][0])])
        else:
            idxs, jdxs = zip(*verts)
            pxl_ar = [0]
            i_lst = []
            j_lst = []
            for n in range(len(idxs) - 1):
                i0, i1 = idxs[n], idxs[n + 1]
                j0, j1 = jdxs[n], jdxs[n + 1]
                num = int(np.sqrt((i1 - i0) ** 2 + (j1 - j0) ** 2) * 2)  # *2 to be safe
                if not num:
                    continue

                ivec = np.linspace(i0, i1, num).astype(int)
                jvec = np.linspace(j0, j1, num).astype(int)

                new_ij = [
                    (ivec[v], jvec[u])
                    for v, u in zip(range(len(ivec) - 1), range(len(jvec) - 1))
                    if ivec[v + 1] != ivec[v] or jvec[u + 1] != jvec[u]
                ]
                new_ij.append((ivec[-1], jvec[-1]))
                new_is, new_js = zip(*new_ij)
                if not i_lst:
                    i_lst, j_lst = list(new_is), list(new_js)
                    i_ar, j_ar = np.asarray(new_is), np.asarray(new_js)
                else:
                    i_lst.extend(list(new_is[1:]))
                    j_lst.extend(list(new_js[1:]))
                    i_ar, j_ar = np.asarray(new_is[1:]), np.asarray(new_js[1:])
                if not (i_ar.ndim and i_ar.size):
                    continue
                pxl_ar.extend(
                    (
                        pxl_ar[-1]
                        + np.sqrt((i_ar - i_ar[0]) ** 2 + (j_ar - j_ar[0]) ** 2)
                    ).tolist()
                )

            for p, prof in enumerate(self.profiles):
                z = self.images[p][j_lst, i_lst]
                if z.ndim and z.size:  # ensure no empty array
                    prof.set_xdata(
                        pxl_ar[1:]
                    )  # get rid of initial 0 on pxl_ar (bit hacky)
                    prof.set_ydata(list(z))
                    if self.do_integral:
                        self.integrals[p] = integrate.simpson(z, pxl_ar[1:])
                    else:
                        self.integrals[p] = np.nan
                else:
                    # dummy data for this guy...
                    prof.set_xdata((np.nan,))
                    prof.set_ydata((np.nan,))
            self.integrals_plot.set_ydata(self.integrals)
        self.profax.relim()
        self.profax.autoscale_view()
        self.resax.relim()
        self.resax.autoscale_view()
        self.canvas.draw()
        self.canvas.flush_events()

    def onselect(self, verts):
        # only called when line is finished
        self.pts = verts  # list of vertices `[(Ax1, Ay1), (Ax2, Ay2)]`
        self.canvas.draw_idle()

    def disconnect(self, path=None):
        if path is not None:
            output_dict = {
                &#34;xlabels&#34;: self.xlabels,
                &#34;integrals&#34;: self.integrals,
                &#34;profile_x&#34;: np.transpose(
                    [prof.get_xdata() for prof in self.profiles]
                ).tolist(),
                &#34;profile_y&#34;: np.transpose(
                    [prof.get_ydata() for prof in self.profiles]
                ).tolist(),
            }
        dukit.shared.json2dict.dict_to_json(output_dict, path)
        self.line_selector.disconnect_events()
        self.canvas.draw_idle()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dukit.shared.linecut.BulkLinecutWidget.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self, path=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self, path=None):
    if path is not None:
        output_dict = {
            &#34;xlabels&#34;: self.xlabels,
            &#34;integrals&#34;: self.integrals,
            &#34;profile_x&#34;: np.transpose(
                [prof.get_xdata() for prof in self.profiles]
            ).tolist(),
            &#34;profile_y&#34;: np.transpose(
                [prof.get_ydata() for prof in self.profiles]
            ).tolist(),
        }
    dukit.shared.json2dict.dict_to_json(output_dict, path)
    self.line_selector.disconnect_events()
    self.canvas.draw_idle()</code></pre>
</details>
</dd>
<dt id="dukit.shared.linecut.BulkLinecutWidget.ondraw"><code class="name flex">
<span>def <span class="ident">ondraw</span></span>(<span>self, verts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ondraw(self, verts):
    if len(verts) == 1:
        # change all profiles
        for p, prof in enumerate(self.profiles):
            prof.set_xdata([0])
            prof.set_ydata(self.images[p][int(verts[0][1]), int(verts[0][0])])
    else:
        idxs, jdxs = zip(*verts)
        pxl_ar = [0]
        i_lst = []
        j_lst = []
        for n in range(len(idxs) - 1):
            i0, i1 = idxs[n], idxs[n + 1]
            j0, j1 = jdxs[n], jdxs[n + 1]
            num = int(np.sqrt((i1 - i0) ** 2 + (j1 - j0) ** 2) * 2)  # *2 to be safe
            if not num:
                continue

            ivec = np.linspace(i0, i1, num).astype(int)
            jvec = np.linspace(j0, j1, num).astype(int)

            new_ij = [
                (ivec[v], jvec[u])
                for v, u in zip(range(len(ivec) - 1), range(len(jvec) - 1))
                if ivec[v + 1] != ivec[v] or jvec[u + 1] != jvec[u]
            ]
            new_ij.append((ivec[-1], jvec[-1]))
            new_is, new_js = zip(*new_ij)
            if not i_lst:
                i_lst, j_lst = list(new_is), list(new_js)
                i_ar, j_ar = np.asarray(new_is), np.asarray(new_js)
            else:
                i_lst.extend(list(new_is[1:]))
                j_lst.extend(list(new_js[1:]))
                i_ar, j_ar = np.asarray(new_is[1:]), np.asarray(new_js[1:])
            if not (i_ar.ndim and i_ar.size):
                continue
            pxl_ar.extend(
                (
                    pxl_ar[-1]
                    + np.sqrt((i_ar - i_ar[0]) ** 2 + (j_ar - j_ar[0]) ** 2)
                ).tolist()
            )

        for p, prof in enumerate(self.profiles):
            z = self.images[p][j_lst, i_lst]
            if z.ndim and z.size:  # ensure no empty array
                prof.set_xdata(
                    pxl_ar[1:]
                )  # get rid of initial 0 on pxl_ar (bit hacky)
                prof.set_ydata(list(z))
                if self.do_integral:
                    self.integrals[p] = integrate.simpson(z, pxl_ar[1:])
                else:
                    self.integrals[p] = np.nan
            else:
                # dummy data for this guy...
                prof.set_xdata((np.nan,))
                prof.set_ydata((np.nan,))
        self.integrals_plot.set_ydata(self.integrals)
    self.profax.relim()
    self.profax.autoscale_view()
    self.resax.relim()
    self.resax.autoscale_view()
    self.canvas.draw()
    self.canvas.flush_events()</code></pre>
</details>
</dd>
<dt id="dukit.shared.linecut.BulkLinecutWidget.onselect"><code class="name flex">
<span>def <span class="ident">onselect</span></span>(<span>self, verts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onselect(self, verts):
    # only called when line is finished
    self.pts = verts  # list of vertices `[(Ax1, Ay1), (Ax2, Ay2)]`
    self.canvas.draw_idle()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dukit.shared.linecut.LinecutSelectionWidget"><code class="flex name class">
<span>class <span class="ident">LinecutSelectionWidget</span></span>
<span>(</span><span>imax, lineax, data, style=None, useblit=False)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="how-to-use">How To Use</h2>
<p>fig, axs = plt.subplots(ncols=2)
axs[0].imshow(data) # (data may be nans if you want empty selector)
selector = LinecutSelectionWidget(axs[0], axs[1], &hellip;)
plt.show()
selector.disconnect()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LinecutSelectionWidget:
    &#34;&#34;&#34;
    How to Use
    ----------
    fig, axs = plt.subplots(ncols=2)
    axs[0].imshow(data) # (data may be nans if you want empty selector)
    selector = LinecutSelectionWidget(axs[0], axs[1], ...)
    plt.show()
    selector.disconnect()

    &#34;&#34;&#34;

    def __init__(self, imax, lineax, data, style=None, useblit=False):
        # check that input ax has an imshow (else not so useful eh)
        if not any([[isinstance(t, AxesImage) for t in imax.get_children()]]):
            raise ValueError(&#34;input axis does not contain an AxesImage (imshow).&#34;)

        self.data = data
        self.imax = imax
        self.lineax = lineax
        self.integral = 0

        self.canvas = self.imax.figure.canvas

        dflt_style = {
            &#34;lineprops&#34;: {
                &#34;color&#34;: &#34;k&#34;,
                &#34;linestyle&#34;: &#34;-&#34;,
                &#34;linewidth&#34;: 1.0,
                &#34;alpha&#34;: 0.5,
            },
            &#34;markerprops&#34;: {
                &#34;marker&#34;: &#34;o&#34;,
                &#34;markersize&#34;: 2.0,
                &#34;mec&#34;: &#34;k&#34;,
                &#34;mfc&#34;: &#34;k&#34;,
                &#34;alpha&#34;: 0.5,
            },
        }

        self.lp = dflt_style[&#34;lineprops&#34;]
        self.mp = dflt_style[&#34;markerprops&#34;]
        if style is not None:
            if &#34;lineprops&#34; in style and isinstance(style[&#34;lineprops&#34;], dict):
                for key, item in style[&#34;lineprops&#34;].items():
                    self.lp[key] = item
            if &#34;markerprops&#34; in style and isinstance(style[&#34;markerprops&#34;], dict):
                for key, item in style[&#34;markerprops&#34;].items():
                    self.mp[key] = item

        vsr = 7.5 * self.mp[&#34;markersize&#34;]  # linear scaling on what our select radius is

        (self.profile,) = self.lineax.plot([1, 2, 3], [1, 2, 3], &#34;ko-&#34;)
        self.lineax.title.set_text(f&#34;Integral: {self.integral}&#34;)

        self.pts = []
        self.line_selector = dukit.shared.widget.LineSelector(
            imax,
            self.onselect,
            ondraw=self.ondraw,
            lineprops=self.lp,
            markerprops=self.mp,
            vertex_select_radius=vsr,
            useblit=useblit,
        )

    def ondraw(self, verts):
        if len(verts) == 1:
            self.profile.set_xdata([0])
            self.profile.set_ydata(self.data[int(verts[0][1]), int(verts[0][0])])
            self.lineax.title.set_text(f&#34;Integral: {self.integral}&#34;)
        else:
            idxs, jdxs = zip(*verts)
            t_ar = [0]
            i_lst = []
            j_lst = []
            for n in range(len(idxs) - 1):
                i0, i1 = idxs[n], idxs[n + 1]
                j0, j1 = jdxs[n], jdxs[n + 1]
                num = int(np.sqrt((i1 - i0) ** 2 + (j1 - j0) ** 2) * 2)  # *2 to be safe
                if not num:
                    continue

                ivec = np.linspace(i0, i1, num).astype(int)
                jvec = np.linspace(j0, j1, num).astype(int)

                new_ij = [
                    (ivec[v], jvec[u])
                    for v, u in zip(range(len(ivec) - 1), range(len(jvec) - 1))
                    if ivec[v + 1] != ivec[v] or jvec[u + 1] != jvec[u]
                ]
                new_ij.append((ivec[-1], jvec[-1]))
                new_is, new_js = zip(*new_ij)
                if not i_lst:
                    i_lst, j_lst = list(new_is), list(new_js)
                    i_ar, j_ar = np.asarray(new_is), np.asarray(new_js)
                else:
                    i_lst.extend(list(new_is[1:]))
                    j_lst.extend(list(new_js[1:]))
                    i_ar, j_ar = np.asarray(new_is[1:]), np.asarray(new_js[1:])
                if not (i_ar.ndim and i_ar.size):
                    continue
                t_ar.extend(
                    (
                        t_ar[-1]
                        + np.sqrt((i_ar - i_ar[0]) ** 2 + (j_ar - j_ar[0]) ** 2)
                    ).tolist()
                )

            z = self.data[j_lst, i_lst]
            if z.ndim and z.size:  # ensure no empty array
                self.profile.set_xdata(
                    t_ar[1:]
                )  # get rid of initial 0 on t_ar (bit hacky)
                self.profile.set_ydata(list(z))
                self.integral = integrate.simpson(z, t_ar[1:])
                self.lineax.title.set_text(f&#34;Integral: {self.integral:.6e}&#34;)
        self.lineax.relim()
        self.lineax.autoscale_view()
        self.canvas.draw()
        self.canvas.flush_events()

    def onselect(self, verts):
        # only called when line is finished
        self.pts = verts  # list of vertices `[(Ax1, Ay1), (Ax2, Ay2)]`
        self.canvas.draw_idle()

    def disconnect(self):
        self.line_selector.disconnect_events()
        self.canvas.draw_idle()
        print()
        print(&#34;profile xdata:&#34;)
        print(self.profile.get_xdata())
        print(&#34;profile ydata:&#34;)
        print(self.profile.get_ydata())
        print(&#34;integral:&#34;)
        print(self.integral)
        print()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dukit.shared.linecut.LinecutSelectionWidget.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    self.line_selector.disconnect_events()
    self.canvas.draw_idle()
    print()
    print(&#34;profile xdata:&#34;)
    print(self.profile.get_xdata())
    print(&#34;profile ydata:&#34;)
    print(self.profile.get_ydata())
    print(&#34;integral:&#34;)
    print(self.integral)
    print()</code></pre>
</details>
</dd>
<dt id="dukit.shared.linecut.LinecutSelectionWidget.ondraw"><code class="name flex">
<span>def <span class="ident">ondraw</span></span>(<span>self, verts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ondraw(self, verts):
    if len(verts) == 1:
        self.profile.set_xdata([0])
        self.profile.set_ydata(self.data[int(verts[0][1]), int(verts[0][0])])
        self.lineax.title.set_text(f&#34;Integral: {self.integral}&#34;)
    else:
        idxs, jdxs = zip(*verts)
        t_ar = [0]
        i_lst = []
        j_lst = []
        for n in range(len(idxs) - 1):
            i0, i1 = idxs[n], idxs[n + 1]
            j0, j1 = jdxs[n], jdxs[n + 1]
            num = int(np.sqrt((i1 - i0) ** 2 + (j1 - j0) ** 2) * 2)  # *2 to be safe
            if not num:
                continue

            ivec = np.linspace(i0, i1, num).astype(int)
            jvec = np.linspace(j0, j1, num).astype(int)

            new_ij = [
                (ivec[v], jvec[u])
                for v, u in zip(range(len(ivec) - 1), range(len(jvec) - 1))
                if ivec[v + 1] != ivec[v] or jvec[u + 1] != jvec[u]
            ]
            new_ij.append((ivec[-1], jvec[-1]))
            new_is, new_js = zip(*new_ij)
            if not i_lst:
                i_lst, j_lst = list(new_is), list(new_js)
                i_ar, j_ar = np.asarray(new_is), np.asarray(new_js)
            else:
                i_lst.extend(list(new_is[1:]))
                j_lst.extend(list(new_js[1:]))
                i_ar, j_ar = np.asarray(new_is[1:]), np.asarray(new_js[1:])
            if not (i_ar.ndim and i_ar.size):
                continue
            t_ar.extend(
                (
                    t_ar[-1]
                    + np.sqrt((i_ar - i_ar[0]) ** 2 + (j_ar - j_ar[0]) ** 2)
                ).tolist()
            )

        z = self.data[j_lst, i_lst]
        if z.ndim and z.size:  # ensure no empty array
            self.profile.set_xdata(
                t_ar[1:]
            )  # get rid of initial 0 on t_ar (bit hacky)
            self.profile.set_ydata(list(z))
            self.integral = integrate.simpson(z, t_ar[1:])
            self.lineax.title.set_text(f&#34;Integral: {self.integral:.6e}&#34;)
    self.lineax.relim()
    self.lineax.autoscale_view()
    self.canvas.draw()
    self.canvas.flush_events()</code></pre>
</details>
</dd>
<dt id="dukit.shared.linecut.LinecutSelectionWidget.onselect"><code class="name flex">
<span>def <span class="ident">onselect</span></span>(<span>self, verts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onselect(self, verts):
    # only called when line is finished
    self.pts = verts  # list of vertices `[(Ax1, Ay1), (Ax2, Ay2)]`
    self.canvas.draw_idle()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dukit.shared" href="index.html">dukit.shared</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dukit.shared.linecut.BulkLinecutWidget" href="#dukit.shared.linecut.BulkLinecutWidget">BulkLinecutWidget</a></code></h4>
<ul class="">
<li><code><a title="dukit.shared.linecut.BulkLinecutWidget.disconnect" href="#dukit.shared.linecut.BulkLinecutWidget.disconnect">disconnect</a></code></li>
<li><code><a title="dukit.shared.linecut.BulkLinecutWidget.ondraw" href="#dukit.shared.linecut.BulkLinecutWidget.ondraw">ondraw</a></code></li>
<li><code><a title="dukit.shared.linecut.BulkLinecutWidget.onselect" href="#dukit.shared.linecut.BulkLinecutWidget.onselect">onselect</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dukit.shared.linecut.LinecutSelectionWidget" href="#dukit.shared.linecut.LinecutSelectionWidget">LinecutSelectionWidget</a></code></h4>
<ul class="">
<li><code><a title="dukit.shared.linecut.LinecutSelectionWidget.disconnect" href="#dukit.shared.linecut.LinecutSelectionWidget.disconnect">disconnect</a></code></li>
<li><code><a title="dukit.shared.linecut.LinecutSelectionWidget.ondraw" href="#dukit.shared.linecut.LinecutSelectionWidget.ondraw">ondraw</a></code></li>
<li><code><a title="dukit.shared.linecut.LinecutSelectionWidget.onselect" href="#dukit.shared.linecut.LinecutSelectionWidget.onselect">onselect</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>