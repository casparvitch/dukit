<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dukit.polygon API documentation</title>
<meta name="description" content="This module holds the Polygon class …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dukit.polygon</code></h1>
</header>
<section id="section-intro">
<p>This module holds the Polygon class.</p>
<p>A class to compute if a point lies inside/outside/on-side of a polygon.
Also defined is a function (polygon_selector) that can be called to select a polygon
region on an image.</p>
<p>For use check examples.</p>
<p>Apologies for lack of typing, I don't understand sufficiently and it
currently <em>just works</em>.</p>
<h2 id="polygon">Polygon</h2>
<p>This is a Python 3 implementation of the Sloan's improved version of the
Nordbeck and Rystedt algorithm, published in the paper:</p>
<p>SLOAN, S.W. (1985): A point-in-polygon program.
Adv. Eng. Software, Vol 7, No. 1, pp 45-47.</p>
<p>This class has 1 method (is_inside) that returns the minimum distance to the
nearest point of the polygon:</p>
<p>If is_inside &lt; 0 then point is outside the polygon.
If is_inside = 0 then point in on a side of the polygon.
If is_inside &gt; 0 then point is inside the polygon.</p>
<p>Sam Scholten copied from:
<a href="http://code.activestate.com/recipes/578381-a-point-in-polygon-program-sw-sloan-algorithm/">http://code.activestate.com/recipes/578381-a-point-in-polygon-program-sw-sloan-algorithm/</a>
-&gt; swapped x &amp; y args order (etc.) for image use.</p>
<h2 id="classes">Classes</h2>
<ul>
<li><code><a title="dukit.polygon.Polygon" href="#dukit.polygon.Polygon">Polygon</a></code></li>
</ul>
<h2 id="functions">Functions</h2>
<ul>
<li><code><a title="dukit.polygon.load_polygon_nodes" href="#dukit.polygon.load_polygon_nodes">load_polygon_nodes()</a></code></li>
<li><code><a title="dukit.polygon.polygon_selector" href="#dukit.polygon.polygon_selector">polygon_selector()</a></code></li>
<li><code><a title="dukit.polygon.PolygonSelectionWidget" href="#dukit.polygon.PolygonSelectionWidget">PolygonSelectionWidget</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
This module holds the Polygon class.

A class to compute if a point lies inside/outside/on-side of a polygon.
Also defined is a function (polygon_selector) that can be called to select a polygon
region on an image.

For use check examples.

Apologies for lack of typing, I don&#39;t understand sufficiently and it
currently *just works*.

Polygon
-------
This is a Python 3 implementation of the Sloan&#39;s improved version of the
Nordbeck and Rystedt algorithm, published in the paper:

SLOAN, S.W. (1985): A point-in-polygon program.
    Adv. Eng. Software, Vol 7, No. 1, pp 45-47.

This class has 1 method (is_inside) that returns the minimum distance to the
nearest point of the polygon:

If is_inside &lt; 0 then point is outside the polygon.
If is_inside = 0 then point in on a side of the polygon.
If is_inside &gt; 0 then point is inside the polygon.

Sam Scholten copied from:
http://code.activestate.com/recipes/578381-a-point-in-polygon-program-sw-sloan-algorithm/
-&gt; swapped x &amp; y args order (etc.) for image use.

Classes
-------
 - `dukit.polygon.Polygon`

Functions
---------
 - `dukit.polygon.load_polygon_nodes`
 - `dukit.polygon.polygon_selector`
 - `dukit.polygon.PolygonSelectionWidget`
&#34;&#34;&#34;

# ============================================================================

__author__ = &#34;Sam Scholten&#34;
__pdoc__ = {
    &#34;dukit.polygon.load_polygon_nodes&#34;: True,
    &#34;dukit.polygon.polygon_selector&#34;: True,
    &#34;dukit.polygon.Polygon&#34;: True,
    &#34;dukit.polygon.PolygonSelectionWidget&#34;: True,
}

# ============================================================================

import numpy as np
import numpy.typing as npt
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from mpl_toolkits.axes_grid1 import make_axes_locatable
import numba
from numba import jit
import dill as pickle

# ============================================================================

from dukit.json2dict import json_to_dict, dict_to_json
from dukit.warn import warn
from dukit.fourier import pad_image
import dukit.widget

# ============================================================================

CMAP_OPTIONS: list[str] = [
    &#34;viridis&#34;,
    &#34;plasma&#34;,
    &#34;inferno&#34;,
    &#34;magma&#34;,
    &#34;cividis&#34;,
    &#34;Greys&#34;,
    &#34;Purples&#34;,
    &#34;Blues&#34;,
    &#34;Greens&#34;,
    &#34;Oranges&#34;,
    &#34;Reds&#34;,
    &#34;YlOrBr&#34;,
    &#34;YlOrRd&#34;,
    &#34;OrRd&#34;,
    &#34;PuRd&#34;,
    &#34;RdPu&#34;,
    &#34;BuPu&#34;,
    &#34;GnBu&#34;,
    &#34;PuBu&#34;,
    &#34;YlGnBu&#34;,
    &#34;PuBuGn&#34;,
    &#34;BuGn&#34;,
    &#34;YlGn&#34;,
    &#34;binary&#34;,
    &#34;gist_yarg&#34;,
    &#34;gist_gray&#34;,
    &#34;gray&#34;,
    &#34;bone&#34;,
    &#34;pink&#34;,
    &#34;spring&#34;,
    &#34;summer&#34;,
    &#34;autumn&#34;,
    &#34;winter&#34;,
    &#34;cool&#34;,
    &#34;Wistia&#34;,
    &#34;hot&#34;,
    &#34;afmhot&#34;,
    &#34;gist_heat&#34;,
    &#34;copper&#34;,
    &#34;PiYG&#34;,
    &#34;PRGn&#34;,
    &#34;BrBG&#34;,
    &#34;PuOr&#34;,
    &#34;RdGy&#34;,
    &#34;RdBu&#34;,
    &#34;RdYlBu&#34;,
    &#34;RdYlGn&#34;,
    &#34;Spectral&#34;,
    &#34;coolwarm&#34;,
    &#34;bwr&#34;,
    &#34;seismic&#34;,
    &#34;twilight&#34;,
    &#34;twilight_shifted&#34;,
    &#34;hsv&#34;,
    &#34;Pastel1&#34;,
    &#34;Pastel2&#34;,
    &#34;Paired&#34;,
    &#34;Accent&#34;,
    &#34;Dark2&#34;,
    &#34;Set1&#34;,
    &#34;Set2&#34;,
    &#34;Set3&#34;,
    &#34;tab10&#34;,
    &#34;tab20&#34;,
    &#34;tab20b&#34;,
    &#34;tab20c&#34;,
    &#34;flag&#34;,
    &#34;prism&#34;,
    &#34;ocean&#34;,
    &#34;gist_earth&#34;,
    &#34;terrain&#34;,
    &#34;gist_stern&#34;,
    &#34;gnuplot&#34;,
    &#34;gnuplot2&#34;,
    &#34;CMRmap&#34;,
    &#34;cubehelix&#34;,
    &#34;brg&#34;,
    &#34;gist_rainbow&#34;,
    &#34;rainbow&#34;,
    &#34;jet&#34;,
    &#34;nipy_spectral&#34;,
    &#34;gist_ncar&#34;,
]

# ============================================================================


@jit(&#34;int8(float64[:], float64[:,:])&#34;, nopython=True, cache=True)
def _is_inside_sm(point, polygon):
    # https://github.com/sasamil/PointInPolygon_Py/blob/master/pointInside.py
    # note this fn works in (x,y) coords (but if point/polygon is consistent all is g)
    conv_map = {0: -1, 1: 1, 2: 0}
    length = polygon.shape[0] - 1
    dy2 = point[1] - polygon[0][1]
    intersections = 0
    ii = 0
    jj = 1

    while ii &lt; length:
        dy = dy2
        dy2 = point[1] - polygon[jj][1]

        # consider only lines which are not completely above/bellow/right from the point
        if dy * dy2 &lt;= 0.0 and (
            point[0] &gt;= polygon[ii][0] or point[0] &gt;= polygon[jj][0]
        ):
            # non-horizontal line
            if dy &lt; 0 or dy2 &lt; 0:
                F = (
                    dy * (polygon[jj][0] - polygon[ii][0]) / (dy - dy2) + polygon[ii][0]
                )  # noqa: N806

                if (
                    point[0] &gt; F
                ):  # if line is left from the point - the ray moving towards left,
                    #  will intersect it
                    intersections += 1
                elif point[0] == F:  # point on line
                    return 2

            # point on upper peak (dy2=dx2=0) or horizontal line
            # (dy=dy2=0 and dx*dx2&lt;=0)
            elif dy2 == 0 and (
                point[0] == polygon[jj][0]
                or (
                    dy == 0
                    and (point[0] - polygon[ii][0]) * (point[0] - polygon[jj][0]) &lt;= 0
                )
            ):
                return 2

        ii = jj
        jj += 1

    # print &#39;intersections =&#39;, intersections
    return conv_map[intersections &amp; 1]


# ============================================================================


@jit(nopython=True, parallel=True, cache=True)
def _is_inside_sm_parallel(points, polygon):
    # https://stackoverflow.com/questions/36399381/ \
    #
    # note this fn works in (x,y) coords (but if point/polygon is consistent all is g.)
    p_ar = np.asfarray(points)
    pts_shape = p_ar.shape[:-1]
    p_ar_flat = p_ar.reshape(
        -1, 2
    )  # shape: (len_y * len_x, 2), i.e. long list of coords (y, x)
    d = np.zeros(p_ar_flat.shape[0], dtype=numba.int8)
    for i in numba.prange(p_ar_flat.shape[0]):
        d[i] = _is_inside_sm(p_ar_flat[i], polygon)
    d = d.reshape(pts_shape)
    return d


# ============================================================================


class Polygon:
    &#34;&#34;&#34;
    Polygon object.

    Arguments
    ---------
    y : array-like
        A sequence of nodal y-coords (all unique).

    x : array-like
        A sequence of nodal x-coords (all unique).
    &#34;&#34;&#34;

    def __init__(self, y, x):
        if len(y) != len(x):
            raise IndexError(&#34;y and x must be equally sized.&#34;)
        self.y = np.asfarray(y)
        self.x = np.asfarray(x)
        # Closes the polygon if were open
        y1, x1 = y[0], x[0]
        yn, xn = y[-1], x[-1]
        if x1 != xn or y1 != yn:
            self.y = np.concatenate((self.y, [y1]))
            self.x = np.concatenate((self.x, [x1]))
        # # Anti-clockwise coordinates # irrelevant...?
        # if _tri_2area_det(self.y, self.x) &lt; 0:
        #     self.y = self.y[::-1]
        #     self.x = self.x[::-1]

    # =============================================== #

    def get_nodes(self):
        # get nodes as a list [[y1,x1], [y2,x2]] etc.
        return [[y, x] for y, x in zip(self.y, self.x)]

    # =============================================== #

    def get_yx(self):
        return np.stack((self.y, self.x), axis=-1)

    # =============================================== #

    def is_inside(self, y, x):
        # return value:
        # &lt;0 - the point is outside the polygon
        # =0 - the point is one edge (boundary)
        # &gt;0 - the point is inside the polygon
        xs = np.asfarray(x)
        ys = np.asfarray(y)
        # Check consistency
        if xs.shape != ys.shape:
            raise IndexError(&#34;x and y has different shapes&#34;)
        # check if single point
        if xs.shape is tuple():
            return _is_inside_sm((y, x), self.get_yx())
        else:
            return _is_inside_sm_parallel(np.stack((ys, xs), axis=-1), self.get_yx())


# ============================================================================


def polygon_selector(
    array: npt.NDArray | str,
    json_output_path: str | None = None,
    json_input_path: str | None = None,
    mean_plus_minus: float | None = None,
    strict_range: tuple[float, float] | None = None,
    print_help: bool = False,
    pad: int = 0,
    **kwargs,
):
    &#34;&#34;&#34;
    Generates mpl (qt) gui for selecting a polygon.
    NOTE: you probably just want to use PolygonSelectionWidget.

    Arguments
    ---------
    array : path OR arraylike
        Path to (numpy) .txt file to load as image.
        OR can be an arraylike directly
    json_output_path : str or path-like, default=&#34;~/poly.json&#34;
        Path to put output json, defaults to home/poly.json.
    json_input_path : str or path-like, default=None
        Loads previous polygons at this path for editing.
    mean_plus_minus : float, default=None
        Plot image with color scaled to mean +- this number.
    strict_range: length 2 list, default=None
        Plot image with color scaled between these values.
        Precedence over mean_plus_minus.
    print_help : bool, default=False
        View this message.
    pad : bool
        If &gt; 0, pads with zeros by &#39;pad&#39; fraction times the image size in both dimensions
        The &#39;padder&#39; (see `qdmpy.sharead.fourier.unpad_image`) is placed in
        the output dict/json.
    **kwargs : dict
        Other keyword arguments to pass to plotters. Currently implemented:
            cmap : string
                Passed to imshow.
            lineprops : dict
                Passed to PolygonSelectionWidget.
            markerprops : dict
                Passed to PolygonSelectionWidget.


    GUI help
    --------
    In the mpl gui, select points to draw polygons.
    Press &#39;enter&#39; to continue in the program.
    Press the &#39;esc&#39; key to reset the current polygon
    Hold &#39;shift&#39; to move all of the vertices (from all polygons)
    Hold &#39;r&#39; and scroll to resize all of the polygons.
    &#39;ctrl&#39; to move a single vertex in the current polygon
    &#39;alt&#39; to start a new polygon (and finalise the current one)
    &#39;del&#39; to clear all lines from the graphic  (thus deleting all polygons).
    &#39;right click&#39; on a vertex (of a finished polygon) to remove it.
    &#34;&#34;&#34;
    if print_help:
        print(
            &#34;&#34;&#34;
        Help
        ====

        Input help
        ----------
        array : path OR arraylike
            Path to (numpy) .txt file to load as image.
            OR can be an arraylike directly
        json_output_path : str or path-like, default=&#34;~/poly.json&#34;
            Path to put output json, defaults to home/poly.json.
        json_input_path : str or path-like, default=None
            Loads previous polygons at this path for editing.
        mean_plus_minus : float, default=None
            Plot image with color scaled to mean +- this number.
        strict_range: length 2 list, default=None
            Plot image with color scaled between these values. 
            Precedence over mean_plus_minus.
        help : bool, Default=False
            View this message.
        **kwargs : dict
        Other keyword arguments to pass to plotters. Currently implemented:
            cmap : string
                Passed to imshow.
            lineprops : dict
                Passed to PolygonSelectionWidget.
            markerprops : dict
                Passed to PolygonSelectionWidget.

        GUI help
        --------
        In the mpl gui, select points to draw polygons.
        Press &#39;enter&#39; to continue in the program.
        Press the &#39;esc&#39; key to reset the current polygon
        Hold &#39;shift&#39; to move all of the vertices (from all polygons)
        Hold &#39;r&#39; and scroll to resize all of the polygons.
        &#39;ctrl&#39; to move a single vertex in the current polygon
        &#39;alt&#39; to start a new polygon (and finalise the current one)
        &#39;del&#39; to clear all lines from the graphic  (thus deleting all polygons).
        &#39;right click&#39; on a vertex (of a finished polygon) to remove it.
        &#34;&#34;&#34;
        )
        return []

    image = np.loadtxt(array) if not isinstance(array, np.ndarray) else array

    if pad &gt; 0:
        image, padder = pad_image(image, &#34;constant&#34;, pad)
    else:
        padder = ((0, 0), (0, 0))

    if json_input_path is None:
        polys = None
        polygon_nodes = None
    else:
        polys = json_to_dict(json_input_path)
        polygon_nodes = polys[&#34;nodes&#34;]
        if &#34;image_shape&#34; in polys:
            shp = polys[&#34;image_shape&#34;]
            if shp[0] != image.shape[0] or shp[1] != image.shape[1]:
                warn(
                    &#34;Image shape loaded polygons were defined on does not match current&#34;
                    &#34; image.&#34;
                )

    fig, ax = plt.subplots()
    minimum = np.nanmin(image)
    maximum = np.nanmax(image)
    if (
        strict_range is not None
        and isinstance(strict_range, (list, np.ndarray, tuple))
        and len(strict_range) == 2
    ):
        vmin, vmax = strict_range
    elif mean_plus_minus is not None and isinstance(mean_plus_minus, (float, int)):
        mean = np.mean(image)
        vmin, vmax = mean - mean_plus_minus, mean + mean_plus_minus
    else:
        vmin, vmax = minimum, maximum
    img = ax.imshow(
        image,
        aspect=&#34;equal&#34;,
        cmap=kwargs[&#34;cmap&#34;] if &#34;cmap&#34; in kwargs else &#34;bwr&#34;,
        vmin=vmin,
        vmax=vmax,
    )

    ax.tick_params(
        axis=&#34;x&#34;,  # changes apply to the x-axis
        which=&#34;both&#34;,  # both major and minor ticks are affected
        bottom=False,  # ticks along the bottom edge are off
        top=False,  # ticks along the top edge are off
        labelbottom=False,
    )
    ax.tick_params(
        axis=&#34;y&#34;,  # changes apply to the y-axis
        which=&#34;both&#34;,  # both major and minor ticks are affected
        left=False,
        right=False,
        labelleft=False,
    )
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
    fig.colorbar(img, cax=cax)
    ax.set_title(&#34;Select polygons&#34;)

    psw = PolygonSelectionWidget(ax, style=kwargs)

    if polygon_nodes is not None:
        psw.load_nodes(polygon_nodes)

    plt.tight_layout()
    plt.show(block=True)
    psw.disconnect()

    pgons = psw.get_polygons_lst()
    if len(pgons) &lt; 1:
        raise RuntimeError(&#34;You didn&#39;t define any polygons&#34;)

    # exclude polygons with nodes &lt; 3
    pgon_lst = [pgon.get_nodes() for pgon in pgons if np.shape(pgon.get_nodes())[0] &gt; 2]
    output_dict = {
        &#34;nodes&#34;: pgon_lst,
        &#34;image_shape&#34;: image.shape,
        &#34;padder&#34;: padder,
    }

    dict_to_json(output_dict, json_output_path)

    return output_dict


# =======================================================================================


class PolygonSelectionWidget:
    &#34;&#34;&#34;
    How to Use
    ----------
    selector = PolygonSelectionWidget(ax, ...)
    plt.show()
    selector.disconnect()
    polygon_lst = selector.get_polygon_lst()

    ```text
    GUI help
    --------
    In the mpl gui, select points to draw polygons.
    Press &#39;enter&#39; to continue in the program.
    Press the &#39;esc&#39; key to reset the current polygon
    Hold &#39;shift&#39; to move all of the vertices (from all polygons)
    Hold &#39;r&#39; and scroll to resize all of the polygons.
    &#39;ctrl&#39; to move a single vertex in the current polygon
    &#39;alt&#39; to start a new polygon (and finalise the current one)
    &#39;del&#39; to clear all lines from the graphic  (thus deleting all polygons).
    &#39;right click&#39; on a vertex (of a finished polygon) to remove it.
    ```
    &#34;&#34;&#34;

    def __init__(self, ax, style=None, base_scale=1.5):
        self.canvas = ax.figure.canvas

        dflt_style = {
            &#34;lineprops&#34;: {
                &#34;color&#34;: &#34;g&#34;,
                &#34;linestyle&#34;: &#34;-&#34;,
                &#34;linewidth&#34;: 1.0,
                &#34;alpha&#34;: 0.5,
            },
            &#34;markerprops&#34;: {
                &#34;marker&#34;: &#34;o&#34;,
                &#34;markersize&#34;: 2.0,
                &#34;mec&#34;: &#34;g&#34;,
                &#34;mfc&#34;: &#34;g&#34;,
                &#34;alpha&#34;: 0.5,
            },
        }

        self.lp = dflt_style[&#34;lineprops&#34;]
        self.mp = dflt_style[&#34;markerprops&#34;]
        if style is not None:
            if &#34;lineprops&#34; in style and isinstance(style[&#34;lineprops&#34;], dict):
                for key, item in style[&#34;lineprops&#34;]:
                    self.lp[key] = item
            if &#34;markerprops&#34; in style and isinstance(style[&#34;markerprops&#34;], dict):
                for key, item in style[&#34;markerprops&#34;]:
                    self.mp[key] = item

        vsr = 7.5 * self.mp[&#34;markersize&#34;]  # linear scaling on what our select radius is
        self.ax = ax
        self.polys = dukit.widget.PolygonSelector(
            ax,
            self.onselect,
            lineprops=self.lp,
            markerprops=self.mp,
            vertex_select_radius=vsr,
            base_scale=base_scale,
        )
        self.pts = []

    def onselect(self, verts):
        # only called when polygon is finished
        self.pts.append(verts)
        self.canvas.draw_idle()

    def disconnect(self):
        self.polys.disconnect_events()
        self.canvas.draw_idle()

    def get_polygons_lst(self):
        lst = []
        for p in self.polys.xy_verts:
            # NOTE opposite indexing convention here (xy_verts -&gt; yx Polygon)
            new_polygon_obj = Polygon(p[1], p[0])
            lst.append(new_polygon_obj)
        return lst

    def load_nodes(self, polygon_nodes):
        # polygon nodes: list of polygons, each polygon is a list of nodes
        for polygon in polygon_nodes:
            nodes_ar = np.array(polygon)

            # x &amp; y convention swapped here
            new_line = Line2D(nodes_ar[:, 1], nodes_ar[:, 0], **self.lp)
            self.ax.add_line(new_line)

            new_line_dict = dict(
                line_obj=new_line, xs=nodes_ar[:, 1], ys=nodes_ar[:, 0]
            )

            self.polys.artists.append(new_line)
            self.polys.lines.append(new_line_dict)  # list of line dicts

        self.polys.draw_polygon()

# ============================================================================

def load_polygon_nodes(poly_path_or_dict : str | dict) -&gt; list[npt.NDArray]:
    &#34;&#34;&#34;
    Loads polygon nodes from json file.

    Arguments
    ---------
    poly_path_or_dict : str | dict
        Path to json or pickle/dill file containing polygon nodes, or directly as a dict

    Returns
    -------
    list[npt.NDArray]
        List of polygons, each polygon is an array of nodes.
    &#34;&#34;&#34;
    def _load_dict(path:str):
        if path.endswith(&#34;json&#34;):
            return json_to_dict(path)
        elif path.endswith(&#34;pickle&#34;):
            with open(path, &#34;rb&#34;) as f:
                return pickle.load(f)
        else:
            raise ValueError(&#34;polygon_nodes path did not end in &#39;json&#39; or &#39;pickle&#39;&#34;)

    if isinstance(poly_path_or_dict, dict):
        return [np.array(p) for p in poly_path_or_dict[&#34;nodes&#34;]]
    elif isinstance(poly_path_or_dict, str):
        return [np.array(p) for p in _load_dict(poly_path_or_dict)[&#34;nodes&#34;]]
    else:
        raise TypeError(&#34;polygons argument was not a dict or string?&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dukit.polygon.load_polygon_nodes"><code class="name flex">
<span>def <span class="ident">load_polygon_nodes</span></span>(<span>poly_path_or_dict: str | dict) ‑> list[numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]]]</span>
</code></dt>
<dd>
<div class="desc"><p>Loads polygon nodes from json file.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>poly_path_or_dict</code></strong> :&ensp;<code>str | dict</code></dt>
<dd>Path to json or pickle/dill file containing polygon nodes, or directly as a dict</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list[npt.NDArray]</code></dt>
<dd>List of polygons, each polygon is an array of nodes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_polygon_nodes(poly_path_or_dict : str | dict) -&gt; list[npt.NDArray]:
    &#34;&#34;&#34;
    Loads polygon nodes from json file.

    Arguments
    ---------
    poly_path_or_dict : str | dict
        Path to json or pickle/dill file containing polygon nodes, or directly as a dict

    Returns
    -------
    list[npt.NDArray]
        List of polygons, each polygon is an array of nodes.
    &#34;&#34;&#34;
    def _load_dict(path:str):
        if path.endswith(&#34;json&#34;):
            return json_to_dict(path)
        elif path.endswith(&#34;pickle&#34;):
            with open(path, &#34;rb&#34;) as f:
                return pickle.load(f)
        else:
            raise ValueError(&#34;polygon_nodes path did not end in &#39;json&#39; or &#39;pickle&#39;&#34;)

    if isinstance(poly_path_or_dict, dict):
        return [np.array(p) for p in poly_path_or_dict[&#34;nodes&#34;]]
    elif isinstance(poly_path_or_dict, str):
        return [np.array(p) for p in _load_dict(poly_path_or_dict)[&#34;nodes&#34;]]
    else:
        raise TypeError(&#34;polygons argument was not a dict or string?&#34;)</code></pre>
</details>
</dd>
<dt id="dukit.polygon.polygon_selector"><code class="name flex">
<span>def <span class="ident">polygon_selector</span></span>(<span>array: numpy.ndarray[typing.Any, numpy.dtype[+_ScalarType_co]] | str, json_output_path: str | None = None, json_input_path: str | None = None, mean_plus_minus: float | None = None, strict_range: tuple[float, float] | None = None, print_help: bool = False, pad: int = 0, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates mpl (qt) gui for selecting a polygon.
NOTE: you probably just want to use PolygonSelectionWidget.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>path OR arraylike</code></dt>
<dd>Path to (numpy) .txt file to load as image.
OR can be an arraylike directly</dd>
<dt><strong><code>json_output_path</code></strong> :&ensp;<code>str</code> or <code>path-like</code>, default=<code>"~/poly.json"</code></dt>
<dd>Path to put output json, defaults to home/poly.json.</dd>
<dt><strong><code>json_input_path</code></strong> :&ensp;<code>str</code> or <code>path-like</code>, default=<code>None</code></dt>
<dd>Loads previous polygons at this path for editing.</dd>
<dt><strong><code>mean_plus_minus</code></strong> :&ensp;<code>float</code>, default=<code>None</code></dt>
<dd>Plot image with color scaled to mean +- this number.</dd>
<dt><strong><code>strict_range</code></strong> :&ensp;<code>length 2 list</code>, default=<code>None</code></dt>
<dd>Plot image with color scaled between these values.
Precedence over mean_plus_minus.</dd>
<dt><strong><code>print_help</code></strong> :&ensp;<code>bool</code>, default=<code>False</code></dt>
<dd>View this message.</dd>
<dt><strong><code>pad</code></strong> :&ensp;<code>bool</code></dt>
<dd>If &gt; 0, pads with zeros by 'pad' fraction times the image size in both dimensions
The 'padder' (see <code>qdmpy.sharead.fourier.unpad_image</code>) is placed in
the output dict/json.</dd>
<dt><strong><code>**kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Other keyword arguments to pass to plotters. Currently implemented:
cmap : string
Passed to imshow.
lineprops : dict
Passed to PolygonSelectionWidget.
markerprops : dict
Passed to PolygonSelectionWidget.</dd>
</dl>
<h2 id="gui-help">Gui Help</h2>
<p>In the mpl gui, select points to draw polygons.
Press 'enter' to continue in the program.
Press the 'esc' key to reset the current polygon
Hold 'shift' to move all of the vertices (from all polygons)
Hold 'r' and scroll to resize all of the polygons.
'ctrl' to move a single vertex in the current polygon
'alt' to start a new polygon (and finalise the current one)
'del' to clear all lines from the graphic
(thus deleting all polygons).
'right click' on a vertex (of a finished polygon) to remove it.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def polygon_selector(
    array: npt.NDArray | str,
    json_output_path: str | None = None,
    json_input_path: str | None = None,
    mean_plus_minus: float | None = None,
    strict_range: tuple[float, float] | None = None,
    print_help: bool = False,
    pad: int = 0,
    **kwargs,
):
    &#34;&#34;&#34;
    Generates mpl (qt) gui for selecting a polygon.
    NOTE: you probably just want to use PolygonSelectionWidget.

    Arguments
    ---------
    array : path OR arraylike
        Path to (numpy) .txt file to load as image.
        OR can be an arraylike directly
    json_output_path : str or path-like, default=&#34;~/poly.json&#34;
        Path to put output json, defaults to home/poly.json.
    json_input_path : str or path-like, default=None
        Loads previous polygons at this path for editing.
    mean_plus_minus : float, default=None
        Plot image with color scaled to mean +- this number.
    strict_range: length 2 list, default=None
        Plot image with color scaled between these values.
        Precedence over mean_plus_minus.
    print_help : bool, default=False
        View this message.
    pad : bool
        If &gt; 0, pads with zeros by &#39;pad&#39; fraction times the image size in both dimensions
        The &#39;padder&#39; (see `qdmpy.sharead.fourier.unpad_image`) is placed in
        the output dict/json.
    **kwargs : dict
        Other keyword arguments to pass to plotters. Currently implemented:
            cmap : string
                Passed to imshow.
            lineprops : dict
                Passed to PolygonSelectionWidget.
            markerprops : dict
                Passed to PolygonSelectionWidget.


    GUI help
    --------
    In the mpl gui, select points to draw polygons.
    Press &#39;enter&#39; to continue in the program.
    Press the &#39;esc&#39; key to reset the current polygon
    Hold &#39;shift&#39; to move all of the vertices (from all polygons)
    Hold &#39;r&#39; and scroll to resize all of the polygons.
    &#39;ctrl&#39; to move a single vertex in the current polygon
    &#39;alt&#39; to start a new polygon (and finalise the current one)
    &#39;del&#39; to clear all lines from the graphic  (thus deleting all polygons).
    &#39;right click&#39; on a vertex (of a finished polygon) to remove it.
    &#34;&#34;&#34;
    if print_help:
        print(
            &#34;&#34;&#34;
        Help
        ====

        Input help
        ----------
        array : path OR arraylike
            Path to (numpy) .txt file to load as image.
            OR can be an arraylike directly
        json_output_path : str or path-like, default=&#34;~/poly.json&#34;
            Path to put output json, defaults to home/poly.json.
        json_input_path : str or path-like, default=None
            Loads previous polygons at this path for editing.
        mean_plus_minus : float, default=None
            Plot image with color scaled to mean +- this number.
        strict_range: length 2 list, default=None
            Plot image with color scaled between these values. 
            Precedence over mean_plus_minus.
        help : bool, Default=False
            View this message.
        **kwargs : dict
        Other keyword arguments to pass to plotters. Currently implemented:
            cmap : string
                Passed to imshow.
            lineprops : dict
                Passed to PolygonSelectionWidget.
            markerprops : dict
                Passed to PolygonSelectionWidget.

        GUI help
        --------
        In the mpl gui, select points to draw polygons.
        Press &#39;enter&#39; to continue in the program.
        Press the &#39;esc&#39; key to reset the current polygon
        Hold &#39;shift&#39; to move all of the vertices (from all polygons)
        Hold &#39;r&#39; and scroll to resize all of the polygons.
        &#39;ctrl&#39; to move a single vertex in the current polygon
        &#39;alt&#39; to start a new polygon (and finalise the current one)
        &#39;del&#39; to clear all lines from the graphic  (thus deleting all polygons).
        &#39;right click&#39; on a vertex (of a finished polygon) to remove it.
        &#34;&#34;&#34;
        )
        return []

    image = np.loadtxt(array) if not isinstance(array, np.ndarray) else array

    if pad &gt; 0:
        image, padder = pad_image(image, &#34;constant&#34;, pad)
    else:
        padder = ((0, 0), (0, 0))

    if json_input_path is None:
        polys = None
        polygon_nodes = None
    else:
        polys = json_to_dict(json_input_path)
        polygon_nodes = polys[&#34;nodes&#34;]
        if &#34;image_shape&#34; in polys:
            shp = polys[&#34;image_shape&#34;]
            if shp[0] != image.shape[0] or shp[1] != image.shape[1]:
                warn(
                    &#34;Image shape loaded polygons were defined on does not match current&#34;
                    &#34; image.&#34;
                )

    fig, ax = plt.subplots()
    minimum = np.nanmin(image)
    maximum = np.nanmax(image)
    if (
        strict_range is not None
        and isinstance(strict_range, (list, np.ndarray, tuple))
        and len(strict_range) == 2
    ):
        vmin, vmax = strict_range
    elif mean_plus_minus is not None and isinstance(mean_plus_minus, (float, int)):
        mean = np.mean(image)
        vmin, vmax = mean - mean_plus_minus, mean + mean_plus_minus
    else:
        vmin, vmax = minimum, maximum
    img = ax.imshow(
        image,
        aspect=&#34;equal&#34;,
        cmap=kwargs[&#34;cmap&#34;] if &#34;cmap&#34; in kwargs else &#34;bwr&#34;,
        vmin=vmin,
        vmax=vmax,
    )

    ax.tick_params(
        axis=&#34;x&#34;,  # changes apply to the x-axis
        which=&#34;both&#34;,  # both major and minor ticks are affected
        bottom=False,  # ticks along the bottom edge are off
        top=False,  # ticks along the top edge are off
        labelbottom=False,
    )
    ax.tick_params(
        axis=&#34;y&#34;,  # changes apply to the y-axis
        which=&#34;both&#34;,  # both major and minor ticks are affected
        left=False,
        right=False,
        labelleft=False,
    )
    divider = make_axes_locatable(ax)
    cax = divider.append_axes(&#34;right&#34;, size=&#34;5%&#34;, pad=0.05)
    fig.colorbar(img, cax=cax)
    ax.set_title(&#34;Select polygons&#34;)

    psw = PolygonSelectionWidget(ax, style=kwargs)

    if polygon_nodes is not None:
        psw.load_nodes(polygon_nodes)

    plt.tight_layout()
    plt.show(block=True)
    psw.disconnect()

    pgons = psw.get_polygons_lst()
    if len(pgons) &lt; 1:
        raise RuntimeError(&#34;You didn&#39;t define any polygons&#34;)

    # exclude polygons with nodes &lt; 3
    pgon_lst = [pgon.get_nodes() for pgon in pgons if np.shape(pgon.get_nodes())[0] &gt; 2]
    output_dict = {
        &#34;nodes&#34;: pgon_lst,
        &#34;image_shape&#34;: image.shape,
        &#34;padder&#34;: padder,
    }

    dict_to_json(output_dict, json_output_path)

    return output_dict</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dukit.polygon.Polygon"><code class="flex name class">
<span>class <span class="ident">Polygon</span></span>
<span>(</span><span>y, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Polygon object.</p>
<h2 id="arguments">Arguments</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>array-like</code></dt>
<dd>A sequence of nodal y-coords (all unique).</dd>
<dt><strong><code>x</code></strong> :&ensp;<code>array-like</code></dt>
<dd>A sequence of nodal x-coords (all unique).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Polygon:
    &#34;&#34;&#34;
    Polygon object.

    Arguments
    ---------
    y : array-like
        A sequence of nodal y-coords (all unique).

    x : array-like
        A sequence of nodal x-coords (all unique).
    &#34;&#34;&#34;

    def __init__(self, y, x):
        if len(y) != len(x):
            raise IndexError(&#34;y and x must be equally sized.&#34;)
        self.y = np.asfarray(y)
        self.x = np.asfarray(x)
        # Closes the polygon if were open
        y1, x1 = y[0], x[0]
        yn, xn = y[-1], x[-1]
        if x1 != xn or y1 != yn:
            self.y = np.concatenate((self.y, [y1]))
            self.x = np.concatenate((self.x, [x1]))
        # # Anti-clockwise coordinates # irrelevant...?
        # if _tri_2area_det(self.y, self.x) &lt; 0:
        #     self.y = self.y[::-1]
        #     self.x = self.x[::-1]

    # =============================================== #

    def get_nodes(self):
        # get nodes as a list [[y1,x1], [y2,x2]] etc.
        return [[y, x] for y, x in zip(self.y, self.x)]

    # =============================================== #

    def get_yx(self):
        return np.stack((self.y, self.x), axis=-1)

    # =============================================== #

    def is_inside(self, y, x):
        # return value:
        # &lt;0 - the point is outside the polygon
        # =0 - the point is one edge (boundary)
        # &gt;0 - the point is inside the polygon
        xs = np.asfarray(x)
        ys = np.asfarray(y)
        # Check consistency
        if xs.shape != ys.shape:
            raise IndexError(&#34;x and y has different shapes&#34;)
        # check if single point
        if xs.shape is tuple():
            return _is_inside_sm((y, x), self.get_yx())
        else:
            return _is_inside_sm_parallel(np.stack((ys, xs), axis=-1), self.get_yx())</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dukit.polygon.Polygon.get_nodes"><code class="name flex">
<span>def <span class="ident">get_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes(self):
    # get nodes as a list [[y1,x1], [y2,x2]] etc.
    return [[y, x] for y, x in zip(self.y, self.x)]</code></pre>
</details>
</dd>
<dt id="dukit.polygon.Polygon.get_yx"><code class="name flex">
<span>def <span class="ident">get_yx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_yx(self):
    return np.stack((self.y, self.x), axis=-1)</code></pre>
</details>
</dd>
<dt id="dukit.polygon.Polygon.is_inside"><code class="name flex">
<span>def <span class="ident">is_inside</span></span>(<span>self, y, x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_inside(self, y, x):
    # return value:
    # &lt;0 - the point is outside the polygon
    # =0 - the point is one edge (boundary)
    # &gt;0 - the point is inside the polygon
    xs = np.asfarray(x)
    ys = np.asfarray(y)
    # Check consistency
    if xs.shape != ys.shape:
        raise IndexError(&#34;x and y has different shapes&#34;)
    # check if single point
    if xs.shape is tuple():
        return _is_inside_sm((y, x), self.get_yx())
    else:
        return _is_inside_sm_parallel(np.stack((ys, xs), axis=-1), self.get_yx())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dukit.polygon.PolygonSelectionWidget"><code class="flex name class">
<span>class <span class="ident">PolygonSelectionWidget</span></span>
<span>(</span><span>ax, style=None, base_scale=1.5)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="how-to-use">How To Use</h2>
<p>selector = PolygonSelectionWidget(ax, &hellip;)
plt.show()
selector.disconnect()
polygon_lst = selector.get_polygon_lst()</p>
<pre><code class="language-text">GUI help
--------
In the mpl gui, select points to draw polygons.
Press 'enter' to continue in the program.
Press the 'esc' key to reset the current polygon
Hold 'shift' to move all of the vertices (from all polygons)
Hold 'r' and scroll to resize all of the polygons.
'ctrl' to move a single vertex in the current polygon
'alt' to start a new polygon (and finalise the current one)
'del' to clear all lines from the graphic  (thus deleting all polygons).
'right click' on a vertex (of a finished polygon) to remove it.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PolygonSelectionWidget:
    &#34;&#34;&#34;
    How to Use
    ----------
    selector = PolygonSelectionWidget(ax, ...)
    plt.show()
    selector.disconnect()
    polygon_lst = selector.get_polygon_lst()

    ```text
    GUI help
    --------
    In the mpl gui, select points to draw polygons.
    Press &#39;enter&#39; to continue in the program.
    Press the &#39;esc&#39; key to reset the current polygon
    Hold &#39;shift&#39; to move all of the vertices (from all polygons)
    Hold &#39;r&#39; and scroll to resize all of the polygons.
    &#39;ctrl&#39; to move a single vertex in the current polygon
    &#39;alt&#39; to start a new polygon (and finalise the current one)
    &#39;del&#39; to clear all lines from the graphic  (thus deleting all polygons).
    &#39;right click&#39; on a vertex (of a finished polygon) to remove it.
    ```
    &#34;&#34;&#34;

    def __init__(self, ax, style=None, base_scale=1.5):
        self.canvas = ax.figure.canvas

        dflt_style = {
            &#34;lineprops&#34;: {
                &#34;color&#34;: &#34;g&#34;,
                &#34;linestyle&#34;: &#34;-&#34;,
                &#34;linewidth&#34;: 1.0,
                &#34;alpha&#34;: 0.5,
            },
            &#34;markerprops&#34;: {
                &#34;marker&#34;: &#34;o&#34;,
                &#34;markersize&#34;: 2.0,
                &#34;mec&#34;: &#34;g&#34;,
                &#34;mfc&#34;: &#34;g&#34;,
                &#34;alpha&#34;: 0.5,
            },
        }

        self.lp = dflt_style[&#34;lineprops&#34;]
        self.mp = dflt_style[&#34;markerprops&#34;]
        if style is not None:
            if &#34;lineprops&#34; in style and isinstance(style[&#34;lineprops&#34;], dict):
                for key, item in style[&#34;lineprops&#34;]:
                    self.lp[key] = item
            if &#34;markerprops&#34; in style and isinstance(style[&#34;markerprops&#34;], dict):
                for key, item in style[&#34;markerprops&#34;]:
                    self.mp[key] = item

        vsr = 7.5 * self.mp[&#34;markersize&#34;]  # linear scaling on what our select radius is
        self.ax = ax
        self.polys = dukit.widget.PolygonSelector(
            ax,
            self.onselect,
            lineprops=self.lp,
            markerprops=self.mp,
            vertex_select_radius=vsr,
            base_scale=base_scale,
        )
        self.pts = []

    def onselect(self, verts):
        # only called when polygon is finished
        self.pts.append(verts)
        self.canvas.draw_idle()

    def disconnect(self):
        self.polys.disconnect_events()
        self.canvas.draw_idle()

    def get_polygons_lst(self):
        lst = []
        for p in self.polys.xy_verts:
            # NOTE opposite indexing convention here (xy_verts -&gt; yx Polygon)
            new_polygon_obj = Polygon(p[1], p[0])
            lst.append(new_polygon_obj)
        return lst

    def load_nodes(self, polygon_nodes):
        # polygon nodes: list of polygons, each polygon is a list of nodes
        for polygon in polygon_nodes:
            nodes_ar = np.array(polygon)

            # x &amp; y convention swapped here
            new_line = Line2D(nodes_ar[:, 1], nodes_ar[:, 0], **self.lp)
            self.ax.add_line(new_line)

            new_line_dict = dict(
                line_obj=new_line, xs=nodes_ar[:, 1], ys=nodes_ar[:, 0]
            )

            self.polys.artists.append(new_line)
            self.polys.lines.append(new_line_dict)  # list of line dicts

        self.polys.draw_polygon()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dukit.polygon.PolygonSelectionWidget.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self):
    self.polys.disconnect_events()
    self.canvas.draw_idle()</code></pre>
</details>
</dd>
<dt id="dukit.polygon.PolygonSelectionWidget.get_polygons_lst"><code class="name flex">
<span>def <span class="ident">get_polygons_lst</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_polygons_lst(self):
    lst = []
    for p in self.polys.xy_verts:
        # NOTE opposite indexing convention here (xy_verts -&gt; yx Polygon)
        new_polygon_obj = Polygon(p[1], p[0])
        lst.append(new_polygon_obj)
    return lst</code></pre>
</details>
</dd>
<dt id="dukit.polygon.PolygonSelectionWidget.load_nodes"><code class="name flex">
<span>def <span class="ident">load_nodes</span></span>(<span>self, polygon_nodes)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_nodes(self, polygon_nodes):
    # polygon nodes: list of polygons, each polygon is a list of nodes
    for polygon in polygon_nodes:
        nodes_ar = np.array(polygon)

        # x &amp; y convention swapped here
        new_line = Line2D(nodes_ar[:, 1], nodes_ar[:, 0], **self.lp)
        self.ax.add_line(new_line)

        new_line_dict = dict(
            line_obj=new_line, xs=nodes_ar[:, 1], ys=nodes_ar[:, 0]
        )

        self.polys.artists.append(new_line)
        self.polys.lines.append(new_line_dict)  # list of line dicts

    self.polys.draw_polygon()</code></pre>
</details>
</dd>
<dt id="dukit.polygon.PolygonSelectionWidget.onselect"><code class="name flex">
<span>def <span class="ident">onselect</span></span>(<span>self, verts)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def onselect(self, verts):
    # only called when polygon is finished
    self.pts.append(verts)
    self.canvas.draw_idle()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#polygon">Polygon</a></li>
<li><a href="#classes">Classes</a></li>
<li><a href="#functions">Functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dukit" href="index.html">dukit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dukit.polygon.load_polygon_nodes" href="#dukit.polygon.load_polygon_nodes">load_polygon_nodes</a></code></li>
<li><code><a title="dukit.polygon.polygon_selector" href="#dukit.polygon.polygon_selector">polygon_selector</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dukit.polygon.Polygon" href="#dukit.polygon.Polygon">Polygon</a></code></h4>
<ul class="">
<li><code><a title="dukit.polygon.Polygon.get_nodes" href="#dukit.polygon.Polygon.get_nodes">get_nodes</a></code></li>
<li><code><a title="dukit.polygon.Polygon.get_yx" href="#dukit.polygon.Polygon.get_yx">get_yx</a></code></li>
<li><code><a title="dukit.polygon.Polygon.is_inside" href="#dukit.polygon.Polygon.is_inside">is_inside</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dukit.polygon.PolygonSelectionWidget" href="#dukit.polygon.PolygonSelectionWidget">PolygonSelectionWidget</a></code></h4>
<ul class="">
<li><code><a title="dukit.polygon.PolygonSelectionWidget.disconnect" href="#dukit.polygon.PolygonSelectionWidget.disconnect">disconnect</a></code></li>
<li><code><a title="dukit.polygon.PolygonSelectionWidget.get_polygons_lst" href="#dukit.polygon.PolygonSelectionWidget.get_polygons_lst">get_polygons_lst</a></code></li>
<li><code><a title="dukit.polygon.PolygonSelectionWidget.load_nodes" href="#dukit.polygon.PolygonSelectionWidget.load_nodes">load_nodes</a></code></li>
<li><code><a title="dukit.polygon.PolygonSelectionWidget.onselect" href="#dukit.polygon.PolygonSelectionWidget.onselect">onselect</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>